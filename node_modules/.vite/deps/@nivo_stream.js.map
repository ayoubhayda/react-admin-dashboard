{
  "version": 3,
  "sources": ["../../@nivo/stream/src/StreamLayer.tsx", "../../@nivo/stream/src/StreamLayers.tsx", "../../@nivo/stream/src/StreamDots.tsx", "../../@nivo/stream/src/StreamSlicesItem.tsx", "../../@nivo/stream/src/StreamSlices.tsx", "../../@nivo/stream/src/props.ts", "../../@nivo/stream/src/StreamDotsItem.tsx", "../../@nivo/stream/src/LayerTooltip.tsx", "../../@nivo/stream/src/StackTooltip.tsx", "../../@nivo/stream/src/Stream.tsx", "../../@nivo/stream/src/hooks.ts", "../../@nivo/stream/src/ResponsiveStream.tsx"],
  "sourcesContent": ["import { useCallback, createElement, MouseEvent } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { InheritedColorConfigCustomFunction } from '@nivo/colors'\nimport { useTooltip } from '@nivo/tooltip'\nimport { StreamCommonProps, StreamDatum, StreamLayerData } from './types'\n\ninterface StreamLayerProps<RawDatum extends StreamDatum> {\n    layer: StreamLayerData\n    fillOpacity: number\n    borderWidth: number\n    getBorderColor: InheritedColorConfigCustomFunction<StreamLayerData>\n    isInteractive: boolean\n    tooltip: StreamCommonProps<RawDatum>['tooltip']\n}\n\nexport const StreamLayer = <RawDatum extends StreamDatum>({\n    layer,\n    fillOpacity,\n    borderWidth,\n    getBorderColor,\n    isInteractive,\n    tooltip,\n}: StreamLayerProps<RawDatum>) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<SVGPathElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { layer }), event, 'left')\n        },\n        [showTooltipFromEvent, layer]\n    )\n\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedPath = useAnimatedPath(layer.path)\n    const animatedProps = useSpring({\n        color: layer.color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={layer.fill ? layer.fill : animatedProps.color}\n            fillOpacity={fillOpacity}\n            stroke={getBorderColor(layer)}\n            strokeWidth={borderWidth}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? hideTooltip : undefined}\n        />\n    )\n}\n", "import { InheritedColorConfigCustomFunction } from '@nivo/colors'\nimport { StreamLayer } from './StreamLayer'\nimport { StreamCommonProps, StreamLayerData, StreamDatum } from './types'\n\ninterface StreamLayersProps<RawDatum extends StreamDatum> {\n    layers: StreamLayerData[]\n    fillOpacity: number\n    borderWidth: number\n    getBorderColor: InheritedColorConfigCustomFunction<StreamLayerData>\n    isInteractive: boolean\n    tooltip: StreamCommonProps<RawDatum>['tooltip']\n}\n\nexport const StreamLayers = <RawDatum extends StreamDatum>({\n    layers,\n    fillOpacity,\n    borderWidth,\n    getBorderColor,\n    isInteractive,\n    tooltip,\n}: StreamLayersProps<RawDatum>) => (\n    <g>\n        {layers.map((layer, i) => (\n            <StreamLayer<RawDatum>\n                key={i}\n                layer={layer}\n                getBorderColor={getBorderColor}\n                borderWidth={borderWidth}\n                fillOpacity={fillOpacity}\n                isInteractive={isInteractive}\n                tooltip={tooltip}\n            />\n        ))}\n    </g>\n)\n", "import { createElement } from 'react'\nimport { StreamSvgProps, StreamLayerDatum, StreamDatum } from './types'\n\ninterface StreamDotsProps<RawDatum extends StreamDatum> {\n    id: string | number\n    color: string\n    data: StreamLayerDatum[]\n    dotComponent: Exclude<StreamSvgProps<RawDatum>['dotComponent'], undefined>\n    position: 'start' | 'center' | 'end'\n    getSize: (datum: StreamLayerDatum) => number\n    getColor: (datum: StreamLayerDatum) => string\n    getBorderWidth: (datum: StreamLayerDatum) => number\n    getBorderColor: (datum: StreamLayerDatum) => string\n}\n\nconst getDotY = <RawDatum extends StreamDatum>(\n    datum: StreamLayerDatum,\n    position: StreamDotsProps<RawDatum>['position']\n) => {\n    let y = datum.y2\n    if (position === 'center') {\n        y = datum.y1 + (datum.y2 - datum.y1) / 2\n    } else if (position === 'start') {\n        y = datum.y1\n    }\n\n    return y\n}\n\nexport const StreamDots = <RawDatum extends StreamDatum>({\n    data,\n    dotComponent,\n    position,\n    getSize,\n    getColor,\n    getBorderWidth,\n    getBorderColor,\n}: StreamDotsProps<RawDatum>) => (\n    <>\n        {data.map((datum, i) => {\n            return createElement(dotComponent, {\n                key: i,\n                datum,\n                x: datum.x,\n                y: getDotY<RawDatum>(datum, position),\n                size: getSize(datum),\n                color: getColor(datum),\n                borderWidth: getBorderWidth(datum),\n                borderColor: getBorderColor(datum),\n            })\n        })}\n    </>\n)\n", "import { createElement, useCallback, useState, MouseEvent } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { StreamCommonProps, StreamDatum, StreamSliceData } from './types'\n\ninterface StreamSlicesItemProps<RawDatum extends StreamDatum> {\n    slice: StreamSliceData\n    height: number\n    tooltip: StreamCommonProps<RawDatum>['stackTooltip']\n}\n\nexport const StreamSlicesItem = <RawDatum extends StreamDatum>({\n    slice,\n    height,\n    tooltip,\n}: StreamSlicesItemProps<RawDatum>) => {\n    const [isHover, setIsHover] = useState(false)\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            setIsHover(true)\n            showTooltipFromEvent(createElement(tooltip, { slice }), event, 'left')\n        },\n        [setIsHover, showTooltipFromEvent, tooltip, slice]\n    )\n\n    const handleMouseLeave = useCallback(() => {\n        setIsHover(false)\n        hideTooltip()\n    }, [setIsHover, hideTooltip])\n\n    return (\n        <g transform={`translate(${slice.x}, 0)`}>\n            {isHover && (\n                <line\n                    x1={0}\n                    x2={0}\n                    y1={0}\n                    y2={height}\n                    stroke=\"#000\"\n                    strokeOpacity={0.35}\n                    strokeWidth={1}\n                />\n            )}\n            <rect\n                x={-20}\n                width={40}\n                height={height}\n                fill=\"#000\"\n                fillOpacity={0}\n                onMouseEnter={handleMouseHover}\n                onMouseMove={handleMouseHover}\n                onMouseLeave={handleMouseLeave}\n            />\n        </g>\n    )\n}\n", "import { StreamSliceData, StreamDatum, StreamCommonProps } from './types'\nimport { StreamSlicesItem } from './StreamSlicesItem'\n\ninterface StreamSlicesProps<RawDatum extends StreamDatum> {\n    slices: StreamSliceData[]\n    height: number\n    tooltip: StreamCommonProps<RawDatum>['stackTooltip']\n}\n\nexport const StreamSlices = <RawDatum extends StreamDatum>({\n    slices,\n    height,\n    tooltip,\n}: StreamSlicesProps<RawDatum>) => (\n    <g>\n        {slices.map(slice => (\n            <StreamSlicesItem<RawDatum>\n                key={slice.index}\n                slice={slice}\n                height={height}\n                tooltip={tooltip}\n            />\n        ))}\n    </g>\n)\n", "import { StackOrder, StackOffset, AreaCurve } from '@nivo/core'\nimport { StreamCommonProps, StreamLayerId } from './types'\nimport { StreamDotsItem } from './StreamDotsItem'\nimport { LayerTooltip } from './LayerTooltip'\nimport { StackTooltip } from './StackTooltip'\n\nexport const defaultProps = {\n    label: 'id',\n\n    order: 'none' as StackOrder,\n    offsetType: 'wiggle' as StackOffset,\n    curve: 'catmullRom' as AreaCurve,\n\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: false,\n    enableGridY: true,\n\n    colors: { scheme: 'nivo' } as StreamCommonProps<any>['colors'],\n    fillOpacity: 1,\n    borderWidth: 0,\n    borderColor: {\n        from: 'color',\n        modifiers: [['darker', 1]],\n    } as StreamCommonProps<any>['borderColor'],\n\n    enableDots: false,\n    dotPosition: 'center' as StreamCommonProps<any>['dotPosition'],\n    dotComponent: StreamDotsItem,\n    dotSize: 6,\n    dotColor: { from: 'color' },\n    dotBorderWidth: 0,\n    dotBorderColor: { from: 'color' },\n\n    isInteractive: true,\n    tooltip: LayerTooltip,\n    enableStackTooltip: true,\n    stackTooltip: StackTooltip,\n\n    legends: [],\n    legendLabel: 'id',\n\n    role: 'application',\n}\n\nexport const svgDefaultProps = {\n    ...defaultProps,\n    layers: ['grid', 'axes', 'layers', 'dots', 'slices', 'legends'] as StreamLayerId[],\n\n    defs: [],\n    fill: [],\n\n    animate: true,\n    motionConfig: 'default',\n\n    role: 'img',\n    isFocusable: false,\n}\n", "import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\n\nexport interface StreamDotsItemProps {\n    x: number\n    y: number\n    size: number\n    color: string\n    borderWidth: number\n    borderColor: string\n}\n\nexport const StreamDotsItem = ({\n    x,\n    y,\n    size,\n    color,\n    borderWidth,\n    borderColor,\n}: StreamDotsItemProps) => {\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size * 0.5,\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.circle\n            cx={animatedProps.x}\n            cy={animatedProps.y}\n            r={animatedProps.radius}\n            fill={animatedProps.color}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n        />\n    )\n}\n", "import { BasicTooltip } from '@nivo/tooltip'\nimport { TooltipProps } from './types'\n\nexport const LayerTooltip = ({ layer }: TooltipProps) => (\n    <BasicTooltip id={layer.label} enableChip={true} color={layer.color} />\n)\n", "import { useMemo } from 'react'\nimport { TableTooltip, Chip } from '@nivo/tooltip'\nimport { StackTooltipProps } from './types'\n\nexport const StackTooltip = ({ slice }: StackTooltipProps) => {\n    const rows = useMemo(\n        () =>\n            slice.stack.map(p => [\n                <Chip key={p.layerId} color={p.color} />,\n                p.layerLabel,\n                p.formattedValue,\n            ]),\n        [slice]\n    )\n\n    return <TableTooltip rows={rows} />\n}\n", "import { createElement, Fragment, ReactNode } from 'react'\nimport {\n    Container,\n    SvgWrapper,\n    useDimensions,\n    // @ts-ignore\n    bindDefs,\n} from '@nivo/core'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { StreamLayers } from './StreamLayers'\nimport { StreamDots } from './StreamDots'\nimport { StreamSlices } from './StreamSlices'\nimport { useStream } from './hooks'\nimport { svgDefaultProps } from './props'\nimport { StreamDatum, StreamLayerId, StreamSvgProps } from './types'\n\ntype InnerStreamProps<RawDatum extends StreamDatum> = Omit<\n    StreamSvgProps<RawDatum>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerStream = <RawDatum extends StreamDatum>({\n    data,\n    keys,\n    label,\n    valueFormat,\n\n    offsetType,\n    order,\n    curve,\n\n    layers: chartLayers = svgDefaultProps.layers,\n\n    width,\n    height,\n    margin: partialMargin,\n\n    axisTop,\n    axisRight,\n    axisBottom = svgDefaultProps.axisBottom,\n    axisLeft = svgDefaultProps.axisLeft,\n    enableGridX = svgDefaultProps.enableGridX,\n    enableGridY = svgDefaultProps.enableGridY,\n\n    colors,\n    fillOpacity = svgDefaultProps.fillOpacity,\n    borderWidth = svgDefaultProps.borderWidth,\n    borderColor,\n    defs = svgDefaultProps.defs,\n    fill = svgDefaultProps.fill,\n\n    enableDots = svgDefaultProps.enableDots,\n    dotPosition = svgDefaultProps.dotPosition,\n    dotComponent = svgDefaultProps.dotComponent,\n    dotSize,\n    dotColor,\n    dotBorderWidth,\n    dotBorderColor,\n\n    isInteractive = svgDefaultProps.isInteractive,\n    tooltip = svgDefaultProps.tooltip,\n    enableStackTooltip = svgDefaultProps.enableStackTooltip,\n    stackTooltip = svgDefaultProps.stackTooltip,\n\n    legends = svgDefaultProps.legends,\n\n    role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n}: InnerStreamProps<RawDatum>) => {\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        xScale,\n        yScale,\n        layers,\n        slices,\n        getBorderColor,\n        getDotSize,\n        getDotColor,\n        getDotBorderWidth,\n        getDotBorderColor,\n        layerContext,\n    } = useStream<RawDatum>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        keys,\n        label,\n        valueFormat,\n        offsetType,\n        order,\n        curve,\n        colors,\n        borderColor,\n        dotSize,\n        dotColor,\n        dotBorderWidth,\n        dotBorderColor,\n    })\n\n    const boundDefs = bindDefs(defs, layers, fill)\n\n    const layerById: Record<StreamLayerId, ReactNode> = {\n        grid: null,\n        axes: null,\n        layers: null,\n        dots: null,\n        slices: null,\n        legends: null,\n    }\n\n    if (chartLayers.includes('grid')) {\n        layerById.grid = (\n            <Grid\n                key=\"grid\"\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n            />\n        )\n    }\n\n    if (chartLayers.includes('axes')) {\n        layerById.axes = (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        )\n    }\n\n    if (chartLayers.includes('layers')) {\n        layerById.layers = (\n            <StreamLayers<RawDatum>\n                key=\"layers\"\n                layers={layers}\n                fillOpacity={fillOpacity}\n                borderWidth={borderWidth}\n                getBorderColor={getBorderColor}\n                isInteractive={isInteractive}\n                tooltip={tooltip}\n            />\n        )\n    }\n\n    if (chartLayers.includes('dots') && enableDots) {\n        layerById.dots = (\n            <Fragment key=\"dots\">\n                {layers.map(layer => (\n                    <StreamDots\n                        key={layer.id}\n                        id={layer.id}\n                        color={layer.color}\n                        data={layer.data}\n                        dotComponent={dotComponent}\n                        position={dotPosition}\n                        getSize={getDotSize}\n                        getColor={getDotColor}\n                        getBorderWidth={getDotBorderWidth}\n                        getBorderColor={getDotBorderColor}\n                    />\n                ))}\n            </Fragment>\n        )\n    }\n\n    if (chartLayers.includes('slices') && isInteractive && enableStackTooltip) {\n        layerById.slices = (\n            <StreamSlices<RawDatum>\n                key=\"slices\"\n                slices={slices}\n                height={innerHeight}\n                tooltip={stackTooltip}\n            />\n        )\n    }\n\n    if (chartLayers.includes('legends')) {\n        layerById.legends = (\n            <Fragment key=\"legends\">\n                {legends.map((legend, i) => {\n                    const legendData = layers\n                        .map(layer => ({\n                            id: layer.id,\n                            label: layer.label,\n                            color: layer.color,\n                            fill: layer.fill,\n                        }))\n                        .reverse()\n\n                    return (\n                        <BoxLegendSvg\n                            key={i}\n                            {...legend}\n                            containerWidth={innerWidth}\n                            containerHeight={innerHeight}\n                            data={legendData}\n                        />\n                    )\n                })}\n            </Fragment>\n        )\n    }\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            defs={boundDefs}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n        >\n            {chartLayers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Stream = <RawDatum extends StreamDatum>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: StreamSvgProps<RawDatum>) => (\n    <Container\n        {...{\n            animate,\n            isInteractive,\n            motionConfig,\n            renderWrapper,\n            theme,\n        }}\n    >\n        <InnerStream<RawDatum> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n", "import { useMemo } from 'react'\nimport { area, stack as d3Stack } from 'd3-shape'\nimport {\n    useTheme,\n    usePropertyAccessor,\n    useValueFormatter,\n    useCurveInterpolation,\n    // @ts-ignore\n    stackOrderFromProp,\n    // @ts-ignore\n    stackOffsetFromProp,\n} from '@nivo/core'\nimport { useInheritedColor, useOrdinalColorScale } from '@nivo/colors'\nimport {\n    StreamCommonProps,\n    StreamCustomLayerProps,\n    StreamDataProps,\n    StreamDatum,\n    StreamLayerData,\n    StreamLayerDatum,\n    StreamSliceData,\n} from './types'\nimport { defaultProps } from './props'\nimport { createLinearScale, createPointScale } from '@nivo/scales'\n\nexport const useStream = <RawDatum extends StreamDatum>({\n    width,\n    height,\n    data,\n    keys,\n    label = defaultProps.label,\n    valueFormat,\n    offsetType = defaultProps.offsetType,\n    order = defaultProps.order,\n    curve = defaultProps.curve,\n    colors = defaultProps.colors,\n    borderColor = defaultProps.borderColor,\n    dotSize = defaultProps.dotSize,\n    dotColor = defaultProps.dotColor,\n    dotBorderWidth = defaultProps.dotBorderWidth,\n    dotBorderColor = defaultProps.dotBorderColor,\n}: {\n    width: number\n    height: number\n    data: StreamDataProps<RawDatum>['data']\n    keys: StreamDataProps<RawDatum>['keys']\n    label?: StreamCommonProps<RawDatum>['label']\n    valueFormat?: StreamCommonProps<RawDatum>['valueFormat']\n    offsetType?: StreamCommonProps<RawDatum>['offsetType']\n    order?: StreamCommonProps<RawDatum>['order']\n    curve?: StreamCommonProps<RawDatum>['curve']\n    colors?: StreamCommonProps<RawDatum>['colors']\n    dotSize?: StreamCommonProps<RawDatum>['dotSize']\n    dotColor?: StreamCommonProps<RawDatum>['dotColor']\n    dotBorderWidth?: StreamCommonProps<RawDatum>['dotBorderWidth']\n    dotBorderColor?: StreamCommonProps<RawDatum>['dotBorderColor']\n    borderColor?: StreamCommonProps<RawDatum>['borderColor']\n}) => {\n    const areaCurveFactory = useCurveInterpolation(curve)\n    const areaGenerator = useMemo(\n        () =>\n            area<StreamLayerDatum>()\n                .x(({ x }) => x)\n                .y0(({ y1 }) => y1)\n                .y1(({ y2 }) => y2)\n                .curve(areaCurveFactory),\n        [areaCurveFactory]\n    )\n\n    const stack = useMemo(\n        () =>\n            d3Stack<RawDatum, string | number>()\n                .keys(keys)\n                .offset(stackOffsetFromProp(offsetType))\n                .order(stackOrderFromProp(order)),\n        [keys, offsetType, order]\n    )\n\n    const [layers, xScale, yScale] = useMemo(() => {\n        const allMin: number[] = []\n        const allMax: number[] = []\n\n        const layers = stack(data).map(layer => {\n            return layer.map(point => {\n                allMin.push(point[0])\n                allMax.push(point[1])\n\n                return {\n                    ...point,\n                    value: point.data[layer.key] as number,\n                }\n            })\n        })\n\n        const minValue = Math.min(...allMin)\n        const maxValue = Math.max(...allMax)\n\n        const xScale = createPointScale(\n            { type: 'point' },\n            { all: Array.from({ length: data.length }, (_, i) => i), min: 0, max: data.length },\n            width\n        )\n        const yScale = createLinearScale(\n            { type: 'linear', min: minValue },\n            { all: [minValue, maxValue], min: minValue, max: maxValue },\n            height,\n            'y'\n        )\n        return [layers, xScale, yScale]\n    }, [stack, data, width, height])\n\n    const theme = useTheme()\n    const getColor = useOrdinalColorScale<Omit<StreamLayerData, 'label' | 'color' | 'data'>>(\n        colors,\n        'id'\n    )\n    const getBorderColor = useInheritedColor<StreamLayerData>(borderColor, theme)\n\n    const getDotSize = useMemo(\n        () => (typeof dotSize === 'function' ? dotSize : () => dotSize),\n        [dotSize]\n    )\n    const getDotColor = useInheritedColor(dotColor, theme)\n    const getDotBorderWidth = useMemo(\n        () => (typeof dotBorderWidth === 'function' ? dotBorderWidth : () => dotBorderWidth),\n        [dotBorderWidth]\n    )\n    const getDotBorderColor = useInheritedColor(dotBorderColor, theme)\n\n    const getLabel = usePropertyAccessor<\n        Omit<StreamLayerData, 'label' | 'color' | 'data'>,\n        string | number\n    >(label)\n    const formatValue = useValueFormatter(valueFormat)\n\n    const enhancedLayers: StreamLayerData[] = useMemo(\n        () =>\n            layers.map((points, layerIndex) => {\n                const computedPoints: StreamLayerDatum[] = points.map((point, i) => ({\n                    layerId: keys[layerIndex],\n                    layerLabel: '',\n                    index: i,\n                    color: '',\n                    x: xScale(i) as number,\n                    value: point.value,\n                    formattedValue: formatValue(point.value),\n                    y1: yScale(point[0]),\n                    y2: yScale(point[1]),\n                }))\n\n                const layer: Omit<StreamLayerData, 'label' | 'color' | 'data'> = {\n                    id: keys[layerIndex] as string,\n                    path: areaGenerator(computedPoints) as string,\n                }\n\n                const layerWithComputedProperties: Omit<StreamLayerData, 'data'> = {\n                    ...layer,\n                    label: getLabel(layer),\n                    color: getColor(layer),\n                }\n\n                return {\n                    ...layerWithComputedProperties,\n                    data: computedPoints.map(point => {\n                        point.layerLabel = layerWithComputedProperties.label\n                        point.color = layerWithComputedProperties.color\n\n                        return point\n                    }),\n                }\n            }),\n        [layers, keys, getLabel, areaGenerator, getColor, xScale, yScale, formatValue]\n    )\n\n    const slices: StreamSliceData[] = useMemo(\n        () =>\n            Array.from({ length: data.length }, (_, i) => {\n                const sliceStack = enhancedLayers\n                    .map(layer => layer.data[i])\n                    .sort((a, b) => a.y2 - b.y2)\n\n                return {\n                    index: i,\n                    x: enhancedLayers[0].data[i].x,\n                    stack: sliceStack,\n                }\n            }),\n        [data.length, enhancedLayers]\n    )\n\n    const layerContext: StreamCustomLayerProps = useMemo(\n        () => ({\n            xScale,\n            yScale,\n            layers: enhancedLayers,\n            slices,\n        }),\n        [xScale, yScale, enhancedLayers, slices]\n    )\n\n    return {\n        xScale,\n        yScale,\n        layers: enhancedLayers,\n        slices,\n        getBorderColor,\n        getDotSize,\n        getDotColor,\n        getDotBorderWidth,\n        getDotBorderColor,\n        layerContext,\n    }\n}\n", "import { ResponsiveWrapper } from '@nivo/core'\nimport { StreamDatum, StreamSvgProps } from './types'\nimport { Stream } from './Stream'\n\nexport const ResponsiveStream = <RawDatum extends StreamDatum>(\n    props: Omit<StreamSvgProps<RawDatum>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Stream<RawDatum> width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n"],
  "mappings": "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",
  "names": ["StreamLayer", "_ref", "layer", "fillOpacity", "borderWidth", "getBorderColor", "isInteractive", "tooltip", "_useTooltip", "useTooltip", "showTooltipFromEvent", "hideTooltip", "handleMouseHover", "useCallback", "event", "createElement", "_useMotionConfig", "useMotionConfig", "animate", "springConfig", "config", "animatedPath", "useAnimatedPath", "path", "animatedProps", "useSpring", "color", "immediate", "_jsx", "animated", "d", "fill", "stroke", "strokeWidth", "onMouseMove", "onMouseEnter", "onMouseLeave", "undefined", "StreamLayers", "layers", "children", "map", "i", "getDotY", "datum", "position", "y", "y2", "y1", "StreamDots", "data", "dotComponent", "getSize", "getColor", "getBorderWidth", "_Fragment", "key", "x", "size", "borderColor", "StreamSlicesItem", "slice", "height", "_useState", "useState", "isHover", "setIsHover", "handleMouseLeave", "_jsxs", "transform", "x1", "x2", "strokeOpacity", "width", "StreamSlices", "slices", "index", "defaultProps", "label", "order", "offsetType", "curve", "axisBottom", "axisLeft", "enableGridX", "enableGridY", "colors", "scheme", "from", "modifiers", "enableDots", "dotPosition", "radius", "circle", "cx", "cy", "r", "dotSize", "dotColor", "dotBorderWidth", "dotBorderColor", "BasicTooltip", "id", "enableChip", "enableStackTooltip", "stackTooltip", "rows", "useMemo", "stack", "p", "Chip", "layerId", "layerLabel", "formattedValue", "TableTooltip", "legends", "legendLabel", "role", "svgDefaultProps", "_extends", "defs", "motionConfig", "isFocusable", "InnerStream", "keys", "valueFormat", "_ref$layers", "chartLayers", "partialMargin", "margin", "axisTop", "axisRight", "_ref$axisBottom", "_ref$axisLeft", "_ref$enableGridX", "_ref$enableGridY", "_ref$fillOpacity", "_ref$borderWidth", "_ref$defs", "_ref$fill", "_ref$enableDots", "_ref$dotPosition", "_ref$dotComponent", "_ref$isInteractive", "_ref$tooltip", "_ref$enableStackToolt", "_ref$stackTooltip", "_ref$legends", "ariaLabel", "ariaLabelledBy", "ariaDescribedBy", "_useDimensions", "useDimensions", "innerWidth", "innerHeight", "outerWidth", "outerHeight", "_useStream", "_ref$label", "_ref$offsetType", "_ref$order", "_ref$curve", "_ref$colors", "_ref$borderColor", "_ref$dotSize", "_ref$dotColor", "_ref$dotBorderWidth", "_ref$dotBorderColor", "areaCurveFactory", "useCurveInterpolation", "areaGenerator", "area", "_ref2", "y0", "_ref3", "_ref4", "d3Stack", "offset", "stackOffsetFromProp", "stackOrderFromProp", "_useMemo", "allMin", "allMax", "point", "push", "value", "minValue", "Math", "min", "apply", "maxValue", "max", "createPointScale", "type", "all", "Array", "length", "_", "createLinearScale", "xScale", "yScale", "theme", "useTheme", "useOrdinalColorScale", "useInheritedColor", "getDotSize", "getDotColor", "getDotBorderWidth", "getDotBorderColor", "getLabel", "usePropertyAccessor", "formatValue", "useValueFormatter", "enhancedLayers", "points", "layerIndex", "computedPoints", "layerWithComputedProperties", "sliceStack", "sort", "a", "b", "layerContext", "boundDefs", "bindDefs", "layerById", "grid", "axes", "dots", "includes", "Grid", "Axes", "top", "right", "bottom", "left", "Fragment", "legend", "legendData", "reverse", "BoxLegendSvg", "containerWidth", "containerHeight", "SvgWrapper", "_layerById$layer", "Stream", "_ref2$isInteractive", "_ref2$animate", "_ref2$motionConfig", "renderWrapper", "otherProps", "_excluded", "Container", "ResponsiveStream", "props", "ResponsiveWrapper"]
}
